# database

## 三范式

* 原子性 属性不可再分
* 惟一性 非主键必须依赖主键，否则不应该出现在那张表
* 冗余性 要求非主键字段不能由其他非主键字段派生出来


## 隔离级别

* Read uncommitted   脏读
   * 所有事务都可以看到没有提交事务的数据。

* Read committed  导致 不可重复读的读 (Oracle 和 SQL Server 的默认级别)
   * 事务成功提交后才可以被查询到。
   * 事务1读取某行的一瞬间，事务2不能修改该行数据，但是，只要事务1读取完改行数据，事务2就可以对该行数据进行修改, 事物2结束。此时事物1再次读取数据，形成不一致，不可重复读
   
* Repeatable reads  （MySQL 默认的隔离级别）
   * 事物1的执行过程中， 事物2无法修改1的数据，解决不可重复读
   * 事物1执行范围查询，事物2此时可以插入新行，事物1再次读取，导致幻读
* Serializable
   * 增加表级锁, 但会导致 其他事物无法 读， 写， 新增范围锁内的数据， 并发性最低

 * Oracle 只有 Read committed 和 Serializable

 * 隔离级别针对的是事物间读的问题，不能解决写覆盖
   * 在读提交以及更高级的隔离级别下，只要事务A没有提交，事务B永远也无法查到事务A所做的更新，从而事务B在计算要更新的数据时，必定忽略掉了事务A所产生的变更。
   * 解决方法1：  update user set money = money +10 where id =1
   * 解决方法2：  select for update 在读的时候就不让其他人读，并且要每个人都是select for update, 不能有个人是普通的select，那样还是有问题。悲观锁，适合写入多
   * 解决方法3：  更新的时候带版本号，乐观锁，适合写入少

## why B+
 * hash
   * 无法范围查找
 * B
   * 所有节点都包含数据，需要遍历子树查找数据
 * B+
   * 只在叶子节点存数据，并叶子节点间有指针相连，方便遍历，不需要在不同层级节点间跳转

